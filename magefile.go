// +build mage

package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"os/exec"
	"strings"

	"github.com/magefile/mage/mg"
	"github.com/magefile/mage/sh"
	"gitlab.com/dananglin/cv/helpers"
)

const (
	aspellLang             string = "en_GB"
	aspellPersonalWordlist string = "./.aspell/.aspell.en.pws"
	cvJsonDataFile         string = "./data/cv.json"
	cvOutputDir            string = "./__output"
	cvTemplateDir          string = "./template/tex/"
	cvOutputFileName       string = "cv.tex"
	dockerfile             string = "./docker/Dockerfile"
)

// Default sets the default target.
var Default = Pdf

// SpellCheck checks the CV JSON file for spelling errors. If there are any
// misspelt words found the function returns a list of those words in an error.
// Any error found while gathering the list is returned.
// This function depends on the aspell program.
func SpellCheck() error {
	fmt.Printf("Reading data from %s...\n", cvJsonDataFile)

	data, err := ioutil.ReadFile(cvJsonDataFile)
	if err != nil {
		return fmt.Errorf("unable to read data from %s, %s", cvJsonDataFile, err.Error())
	}

	// declare the aspell command and its standard input pipe.
	cmd := exec.Command("aspell", "-d", aspellLang, "-p", aspellPersonalWordlist, "list")
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return err
	}

	// write the CV data to standard input for piping.
	go func() {
		defer stdin.Close()
		io.WriteString(stdin, string(data))
	}()

	// run aspell and get the list of mispelt words (if any).
	// (the output is a string.)
	fmt.Println("Running aspell...")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return err
	}

	list := strings.Split(string(out), "\n")
	if list[len(list)-1] == "" {
		list = list[:len(list)-1]
	}

	if len(list) > 0 {
		var b strings.Builder
		errMsg := fmt.Sprintf("the following spelling errors were found in %s:", cvJsonDataFile)
		b.WriteString(errMsg)

		for _, v := range list {
			s := "\n- " + v
			b.WriteString(s)
		}

		return fmt.Errorf(b.String())
	} else {
		fmt.Println("No spelling errors were found.")
	}

	return nil
}

// Tex takes the CV data file and generates the output tex file from
// template.
func Tex() error {
	fmt.Println("Generating the tex file...")

	mg.Deps(Clean)

	return helpers.CreateCVTex(cvJsonDataFile, cvTemplateDir, cvOutputDir, cvOutputFileName)
}

// Pdf takes the output tex file generated by the Tex target and
// generates the output PDF file.
func Pdf() error {
	mg.Deps(Tex)

	pathArg := "--path=" + cvOutputDir

	fmt.Println("Generating the PDF file...")
	return sh.Run("mtxrun", pathArg, "--script", "context", "cv.tex")
}

// Image builds the CV builder docker image.
func Image() error {
	image := helpers.ImageName()

	return sh.Run("docker", "build", "-f", dockerfile, "-t", image, ".")
}

// PublishImage publishes the CV builder docker image
// to the docker registry.
func PublishImage() error {
	mg.Deps(Image)

	image := helpers.ImageName()
	return sh.Run("docker", "push", image)
}

// Clean removes the directory where the output files
// are generated.
func Clean() error {
	if err := sh.Rm(cvOutputDir); err != nil {
		return err
	}

	return nil
}
